<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image Preview</title>
    <style>
      html, body { height: 100%; margin: 0; background: #000; }
      body { display: flex; align-items: center; justify-content: center; user-select: none; overflow: hidden; }
      #wrap { position: relative; display: inline-block; will-change: transform; transition: transform 0.05s linear; }
      img { max-width: 100vw; max-height: 100vh; object-fit: contain; cursor: grab; display: block; }
      img.grabbing { cursor: grabbing; }
      .zoom { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 8px 16px; color: #fff; align-items: center; }
      .zoom button { background: rgba(255,255,255,0.15); color: #fff; border: 1px solid rgba(255,255,255,0.25); border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; min-width: 32px; }
      .zoom button:hover { background: rgba(255,255,255,0.25); }
      .zoom #zval { min-width: 50px; text-align: center; font-size: 14px; }
      /* Top-right toolbar - matches fullscreen preview layout */
      .toolbar { position: fixed; top: 16px; right: 20px; display: flex; gap: 10px; z-index: 10; }
      .icon-btn { background: #000000; color: #ffffff; border: 1px solid #333333; border-radius: 8px; width: 40px; height: 40px; display: inline-flex; align-items: center; justify-content: center; transition: background-color 0.2s ease, border-color 0.2s ease; outline: none; cursor: pointer; }
      .icon-btn:hover { background: #111111; border-color: #444444; }
      .icon-btn.active { border-color: #ffffff; box-shadow: 0 0 0 1px #ffffff inset; }
      /* Close button */
      .close-btn { position: fixed; top: 16px; right: 20px; z-index: 11; }
      /* Loupe */
      .loupe { position: fixed; width: 240px; height: 240px; border-radius: 50%; border: 1px solid #ffffff; pointer-events: none; background-repeat: no-repeat; box-shadow: 0 2px 12px rgba(0,0,0,0.6); z-index: 11; }
      /* Grid overlay */
      #gridOverlay { position: absolute; inset: 0; pointer-events: none; }
      #gridPanel { position: fixed; top: 66px; right: 70px; background: #000; border: 1px solid #333; border-radius: 8px; padding: 8px; display: none; flex-direction: column; gap: 8px; z-index: 12; }
      #gridPanel .swatches { display: flex; gap: 6px; align-items: center; justify-content: space-between; width: 100%; }
      #gridPanel .swatch { width: 18px; height: 18px; border-radius: 4px; cursor: pointer; }
      #gridPanel .row { display: flex; align-items: center; gap: 6px; justify-content: center; }
      #gridPanel .row .btn { width: 22px; height: 22px; border-radius: 4px; border: 1px solid #444; background: #111; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; line-height: 1; padding: 0; }
      #gridPanel .row .val { color: #fff; font-size: 12px; min-width: 14px; text-align: center; }
      #gridPanel .label { color: #ccc; font-size: 12px; min-width: 10px; text-align: center; }
      #gridPanel .aspect { color: #ccc; font-size: 12px; text-align: center; padding-top: 2px; }

      /* Measure overlay + panel */
      #measureOverlay { position: absolute; inset: 0; pointer-events: none; z-index: 9; transform-origin: center center; }
      #measureHit { position: absolute; inset: 0; z-index: 8; display: none; cursor: crosshair; }
      #measurePanel { position: fixed; top: 66px; right: 220px; background: #000; border: 1px solid #333; border-radius: 8px; padding: 8px; display: none; flex-direction: column; gap: 8px; z-index: 12; width: 280px; box-sizing: border-box; color: #fff; font-size: 12px; }
      #measurePanel .title { font-weight: 600; color: #ddd; }
      #measurePanel label { display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ddd; }
      #measurePanel input[type="number"] { background: #111; color: #fff; border: 1px solid #444; border-radius: 6px; padding: 6px 8px; width: 140px; }
      #measurePanel .grid2 { display: grid; grid-template-columns: auto 1fr; column-gap: 8px; row-gap: 6px; align-items: center; }
      #measurePanel .help { color: #888; }
      #measurePanel .actions { display: flex; gap: 8px; margin-top: 6px; }
      #measurePanel .actions button { background: #111; color: #fff; border: 1px solid #444; border-radius: 6px; padding: 6px 10px; cursor: pointer; }
      #measurePanel .actions button:disabled { opacity: 0.5; cursor: not-allowed; }
    </style>
  </head>
  <body>
    <div id="wrap">
      <img id="preview" alt="" />
      <div id="gridOverlay"></div>
      <div id="measureOverlay"></div>
      <div id="measureHit"></div>
    </div>
    <!-- Toolbar buttons ordered to match fullscreen preview: Measure | Loupe | Grid | Monochrome | Close -->
    <div class="toolbar">
      <button id="measureBtn" class="icon-btn" title="Toggle measure mode" aria-label="Toggle measure mode">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" aria-hidden="true">
          <rect x="3" y="10" width="18" height="4" rx="1.5" stroke="currentColor" stroke-width="1.8"/>
          <path d="M6 10V8 M9 10V7 M12 10V8 M15 10V7 M18 10V8" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
        </svg>
      </button>
      <button id="loupeBtn" class="icon-btn" title="Toggle magnifier" aria-label="Toggle magnifier">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true">
          <circle cx="11" cy="11" r="7" fill="none" stroke="currentColor" stroke-width="2" />
          <path d="M16.5 16.5L21 21" stroke="currentColor" stroke-width="2" />
        </svg>
      </button>
      <button id="gridBtn" class="icon-btn" title="Toggle grid" aria-label="Toggle grid">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <path d="M12 3L12 21" />
          <path d="M3 12L21 12" />
        </svg>
      </button>
      <button id="bw" class="icon-btn" title="Toggle monochrome" aria-label="Toggle monochrome">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" aria-hidden="true">
          <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
          <path d="M12 3 A 9 9 0 0 0 12 21 Z" />
        </svg>
      </button>
      <button id="closeBtn" class="icon-btn" title="Close" aria-label="Close" onclick="window.close()">
        <span style="font-size: 18px;">✕</span>
      </button>
    </div>
    <div id="loupe" class="loupe" style="display:none"></div>
    <div id="gridPanel">
      <div class="swatches">
        <button class="swatch" data-color="white" style="background:#ffffff;border:1px solid #222"></button>
        <button class="swatch" data-color="black" style="background:#000000;border:1px solid #666"></button>
        <button class="swatch" data-color="red" style="background:#ff0000;border:1px solid #222"></button>
      </div>
      <div class="row">
        <span class="label">H</span>
        <button class="btn" id="hDec">−</button>
        <span class="val" id="hVal">1</span>
        <button class="btn" id="hInc">+</button>
      </div>
      <div class="row">
        <span class="label">V</span>
        <button class="btn" id="vDec">−</button>
        <span class="val" id="vVal">1</span>
        <button class="btn" id="vInc">+</button>
      </div>
      <div class="aspect" id="aspectTxt"></div>
    </div>
    <div id="measurePanel">
      <div class="title">Measurement</div>
      <label><input type="radio" name="measureMode" value="relative" checked /> <span>Relative proportion (X and multiples)</span></label>
      <label><input type="radio" name="measureMode" value="absolute" /> <span>Values based on canvas</span></label>
      <div id="measureAbs" style="display:none">
        <div class="grid2">
          <span style="color:#bbb">Width</span>
          <input id="absW" type="number" min="0" step="0.01" />
          <span style="color:#bbb">Height</span>
          <input id="absH" type="number" min="0" step="0.01" />
          <div class="help" style="grid-column:1 / 3">Type either width or height; the other updates by image aspect ratio.</div>
        </div>
        <label style="margin-top:6px"><input id="showSide" type="checkbox" /> <span>Show side distance</span></label>
      </div>
      <div class="actions">
        <button id="mUndo" disabled>Undo</button>
        <button id="mReset" disabled>Reset</button>
      </div>
    </div>
    <div class="zoom"><button id="zout">−</button><span id="zval">100%</span><button id="zin">+</button><button id="zreset">Reset</button></div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const src = params.get('src');
      const rotParam = params.get('rot');
      const isPrint = params.get('print') === '1';
      const cropParam = params.get('crop');
      const crop = (() => {
        if (!cropParam) return null;
        try {
          const raw = JSON.parse(decodeURIComponent(cropParam));
          if (!raw || typeof raw !== 'object') return null;
          const x = Number(raw.x), y = Number(raw.y), w = Number(raw.w), h = Number(raw.h);
          if (![x, y, w, h].every(n => Number.isFinite(n))) return null;
          if (!(w > 0 && h > 0)) return null;
          // Clamp to [0,1] defensively
          const cx = Math.max(0, Math.min(1, x));
          const cy = Math.max(0, Math.min(1, y));
          const cw = Math.max(0, Math.min(1 - cx, w));
          const ch = Math.max(0, Math.min(1 - cy, h));
          return { x: cx, y: cy, w: cw, h: ch };
        } catch {
          return null;
        }
      })();
      const rotation = (() => {
        const n = parseInt(rotParam || '0', 10);
        if (!Number.isFinite(n)) return 0;
        const r = ((n % 360) + 360) % 360;
        return r;
      })();
      const img = document.getElementById('preview');
      const wrap = document.getElementById('wrap');
      const gridOverlay = document.getElementById('gridOverlay');
      const gridPanel = document.getElementById('gridPanel');
      const aspectTxt = document.getElementById('aspectTxt');
      const measureOverlay = document.getElementById('measureOverlay');
      const measureHit = document.getElementById('measureHit');
      const measureBtn = document.getElementById('measureBtn');
      const measurePanel = document.getElementById('measurePanel');
      const absWrap = document.getElementById('measureAbs');
      const absWInput = document.getElementById('absW');
      const absHInput = document.getElementById('absH');
      const showSideInput = document.getElementById('showSide');
      const mUndo = document.getElementById('mUndo');
      const mReset = document.getElementById('mReset');
      let zoom = 1, ox = 0, oy = 0, panning = false, monochrome = false, loupeOn = false, hovering = false;
      let gridOn = false, gridColor = 'white', gridH = 1, gridV = 1;
      let natW = 0, natH = 0;
      let measureOn = false, measureMode = 'relative', showSide = false;
      let measurePoints = []; // [{nx, ny}] in unrotated normalized coords (0..1)
      let draggingIdx = null;
      let sideCursor = null; // {nx, ny} screen-aligned normalized coords
      let absW = '', absH = '';
      const zoomEl = document.querySelector('.zoom');
      const toolbarEl = document.querySelector('.toolbar');

      function isRightAngleRot() { return rotation === 90 || rotation === 270; }
      function effectiveDimsPx() {
        // In rotated views (90/270), what the user perceives as width/height are swapped.
        return isRightAngleRot() ? { w: natH, h: natW } : { w: natW, h: natH };
      }
      function effectiveAspect() {
        const d = effectiveDimsPx();
        if (!(d.w > 0 && d.h > 0)) return 0;
        return d.h / d.w;
      }
      if (src) {
        try {
          img.src = decodeURIComponent(src);
        } catch (e) {
          img.src = src;
        }
      }

      if (isPrint) {
        try { document.title = 'Print'; } catch {}
        try { document.documentElement.style.background = '#fff'; } catch {}
        try { document.body.style.background = '#fff'; } catch {}
        try { if (zoomEl) zoomEl.style.display = 'none'; } catch {}
        try { if (toolbarEl) toolbarEl.style.display = 'none'; } catch {}
        try { gridPanel.style.display = 'none'; } catch {}
        try { measurePanel.style.display = 'none'; } catch {}
        try { loupe.style.display = 'none'; } catch {}
      }

      const zval = document.getElementById('zval');
      const apply = () => {
        wrap.style.transform = `translate(${ox}px, ${oy}px) scale(${zoom})`;
        img.style.filter = monochrome ? 'grayscale(100%)' : 'none';
        img.style.transform = `rotate(${rotation}deg)`;
        img.style.transformOrigin = 'center center';
        // Rotate overlays with the image (measurement + grid), so they track rotation
        gridOverlay.style.transform = `rotate(${rotation}deg)`;
        gridOverlay.style.transformOrigin = 'center center';
        measureOverlay.style.transform = `rotate(${rotation}deg)`;
        measureOverlay.style.transformOrigin = 'center center';
        zval.textContent = Math.round(zoom*100) + '%';
      };
      // Grid helpers
      const gridBtn = document.getElementById('gridBtn');
      const hVal = document.getElementById('hVal');
      const vVal = document.getElementById('vVal');
      const hDec = document.getElementById('hDec');
      const hInc = document.getElementById('hInc');
      const vDec = document.getElementById('vDec');
      const vInc = document.getElementById('vInc');

      function gridLineCss() {
        switch (gridColor) {
          case 'black': return 'rgba(0,0,0,0.85)';
          case 'red': return 'rgba(255,0,0,0.85)';
          default: return 'rgba(255,255,255,0.85)';
        }
      }

      function renderGrid() {
        if (!gridOn) { gridOverlay.innerHTML = ''; return; }
        const color = gridLineCss();
        let html = '';
        for (let i = 0; i < gridV; i++) {
          const pct = ((i + 1) / (gridV + 1)) * 100;
          html += `<div style="position:absolute;top:0;bottom:0;left:${pct}%;width:2px;transform:translateX(-50%);background:${color}"></div>`;
        }
        for (let i = 0; i < gridH; i++) {
          const pct = ((i + 1) / (gridH + 1)) * 100;
          html += `<div style="position:absolute;left:0;right:0;top:${pct}%;height:2px;transform:translateY(-50%);background:${color}"></div>`;
        }
        gridOverlay.innerHTML = html;
      }

      function updateAspect() {
        if (natW > 0 && natH > 0) {
          const d = effectiveDimsPx();
          const r = d.w / d.h;
          if (isFinite(r) && r > 0) {
            aspectTxt.textContent = r >= 1 ? `Aspect: ${r.toFixed(2)}:1` : `Aspect: 1:${(1/r).toFixed(2)}`;
            return;
          }
        }
        aspectTxt.textContent = '';
      }

      function clamp01(v) { return Math.max(0, Math.min(1, v)); }

      function mapClientToUnrotatedNormalized(clientX, clientY) {
        // Use wrap rect (unrotated). Undo rotation around its center.
        const rect = wrap.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = clientX - cx;
        const dy = clientY - cy;
        const theta = (-rotation * Math.PI) / 180;
        const cos = Math.cos(theta);
        const sin = Math.sin(theta);
        const ux = dx * cos - dy * sin;
        const uy = dx * sin + dy * cos;
        const nx = (ux + rect.width / 2) / rect.width;
        const ny = (uy + rect.height / 2) / rect.height;
        return { nx: clamp01(nx), ny: clamp01(ny) };
      }

      function formatNum(v) {
        if (!isFinite(v) || v <= 0) return '';
        if (Math.abs(v) >= 100) return String(Math.round(v));
        if (Math.abs(v) >= 10) return v.toFixed(1);
        return v.toFixed(2);
      }

      function computePairs() {
        const pairs = [];
        const eff = effectiveDimsPx();
        for (let i = 0; i + 1 < measurePoints.length; i += 2) {
          const a = measurePoints[i];
          const b = measurePoints[i + 1];
          const dx = b.nx - a.nx;
          const dy = b.ny - a.ny;
          const pixelDist = (natW > 0 && natH > 0) ? Math.hypot(dx * natW, dy * natH) : Math.hypot(dx, dy);
          // Normalize by effective width so "Values based on canvas" behaves correctly when rotated 90/270.
          const len = (eff.w > 0) ? (pixelDist / eff.w) : pixelDist; // width-normalized
          const midx = (a.nx + b.nx) / 2;
          const midy = (a.ny + b.ny) / 2;
          pairs.push({ idx: i, a, b, len, midx, midy });
        }
        return pairs;
      }

      function renderMeasure() {
        if (!measureOn) {
          measureOverlay.innerHTML = '';
          return;
        }
        const pairs = computePairs();
        // Relative mode labels (X and multiples)
        let labels = pairs.map(p => ({ idx: p.idx, label: '' }));
        if (measureMode === 'relative') {
          const positive = pairs.filter(p => p.len > 0);
          if (positive.length > 0) {
            const minLen = Math.min.apply(null, positive.map(p => p.len));
            labels = pairs.map(p => {
              let label = '';
              if (p.len === minLen) label = 'X';
              else if (minLen > 0) {
                const ratio = p.len / minLen;
                const rounded = Math.round(ratio);
                label = (Math.abs(rounded - ratio) < 0.1) ? `${rounded}x` : `${ratio.toFixed(1)}x`;
              }
              return { idx: p.idx, label };
            });
          }
        } else {
          // Absolute mode: use absW as widthUnits. If absH set only, derive width from aspect.
          const wNum = parseFloat(absW);
          const hNum = parseFloat(absH);
          let widthUnits = (isFinite(wNum) && wNum > 0) ? wNum : 0;
          const aspect = effectiveAspect();
          if (!widthUnits && isFinite(hNum) && hNum > 0 && aspect > 0) widthUnits = hNum / aspect;
          labels = pairs.map(p => {
            const value = widthUnits > 0 ? (p.len * widthUnits) : NaN;
            return { idx: p.idx, label: formatNum(value) };
          });
        }

        // Build SVG in unrotated coords; the overlay itself is rotated via CSS to match the image.
        let svg = `<svg viewBox="0 0 100 100" preserveAspectRatio="none" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none">`;
        pairs.forEach(p => {
          svg += `<line x1="${p.a.nx * 100}" y1="${p.a.ny * 100}" x2="${p.b.nx * 100}" y2="${p.b.ny * 100}" stroke="#00e0ff" stroke-width="1.5" stroke-dasharray="4 4" vector-effect="non-scaling-stroke" opacity="0.9"></line>`;
        });
        pairs.forEach(p => {
          const found = labels.find(l => l.idx === p.idx);
          const label = found ? found.label : '';
          if (!label) return;
          const x = p.midx * 100;
          const y = p.midy * 100;
          // Keep text readable by counter-rotating
          svg += `<text x="${x}" y="${y}" fill="#ffffff" font-size="3" text-anchor="middle" dominant-baseline="middle" transform="rotate(${-rotation} ${x} ${y})" style="paint-order:stroke;stroke:rgba(0,0,0,0.7);stroke-width:1">${label}</text>`;
        });
        svg += `</svg>`;
        measureOverlay.innerHTML = svg;

        // Buttons
        mUndo.disabled = measurePoints.length === 0;
        mReset.disabled = measurePoints.length === 0;
      }

      function renderSideDistance() {
        // Screen-aligned overlay from visible top-left corner of wrap
        const existing = document.getElementById('sideDistanceOverlay');
        if (!measureOn || measureMode !== 'absolute' || !showSide || !sideCursor) {
          if (existing) existing.remove();
          return;
        }
        const rect = wrap.getBoundingClientRect();
        const widthUnits = (() => {
          const wNum = parseFloat(absW);
          const hNum = parseFloat(absH);
          if (isFinite(wNum) && wNum > 0) return wNum;
          const aspect = effectiveAspect();
          if (isFinite(hNum) && hNum > 0 && aspect > 0) return hNum / aspect;
          return 0;
        })();
        const heightUnits = (() => {
          const hNum = parseFloat(absH);
          if (isFinite(hNum) && hNum > 0) return hNum;
          const aspect = effectiveAspect();
          if (widthUnits > 0 && aspect > 0) return widthUnits * aspect;
          return 0;
        })();
        const xDist = widthUnits > 0 ? sideCursor.nx * widthUnits : NaN;
        const yDist = heightUnits > 0 ? sideCursor.ny * heightUnits : NaN;
        const cx = sideCursor.nx * 100;
        const cy = sideCursor.ny * 100;
        const div = existing || document.createElement('div');
        div.id = 'sideDistanceOverlay';
        div.style.position = 'fixed';
        div.style.left = rect.left + 'px';
        div.style.top = rect.top + 'px';
        div.style.width = rect.width + 'px';
        div.style.height = rect.height + 'px';
        div.style.pointerEvents = 'none';
        div.style.zIndex = '12';
        div.innerHTML = `<svg viewBox="0 0 100 100" preserveAspectRatio="none" style="width:100%;height:100%">
          <line x1="0" y1="${cy}" x2="${cx}" y2="${cy}" stroke="#FFCC00" stroke-width="1.5" vector-effect="non-scaling-stroke" opacity="0.95"></line>
          ${isFinite(xDist) && xDist > 0 ? `<text x="${cx/2}" y="${Math.max(2, cy-2)}" fill="#ffffff" font-size="3" text-anchor="middle" dominant-baseline="ideographic" style="paint-order:stroke;stroke:rgba(0,0,0,0.7);stroke-width:1">${formatNum(xDist)}</text>` : ''}
          <line x1="${cx}" y1="0" x2="${cx}" y2="${cy}" stroke="#FFCC00" stroke-width="1.5" vector-effect="non-scaling-stroke" opacity="0.95"></line>
          ${isFinite(yDist) && yDist > 0 ? `<text x="${Math.min(98, cx+2)}" y="${cy/2}" fill="#ffffff" font-size="3" text-anchor="start" dominant-baseline="middle" style="paint-order:stroke;stroke:rgba(0,0,0,0.7);stroke-width:1">${formatNum(yDist)}</text>` : ''}
        </svg>`;
        if (!existing) document.body.appendChild(div);
      }

      gridBtn.addEventListener('click', () => {
        gridOn = !gridOn;
        gridBtn.classList.toggle('active', gridOn);
        gridPanel.style.display = gridOn ? 'flex' : 'none';
        renderGrid();
      });

      document.querySelectorAll('#gridPanel .swatch').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const c = e.currentTarget.getAttribute('data-color');
          if (c) gridColor = c;
          renderGrid();
        });
      });

      hDec.addEventListener('click', () => { gridH = Math.max(1, gridH - 1); hVal.textContent = String(gridH); renderGrid(); });
      hInc.addEventListener('click', () => { gridH = Math.min(12, gridH + 1); hVal.textContent = String(gridH); renderGrid(); });
      vDec.addEventListener('click', () => { gridV = Math.max(1, gridV - 1); vVal.textContent = String(gridV); renderGrid(); });
      vInc.addEventListener('click', () => { gridV = Math.min(12, gridV + 1); vVal.textContent = String(gridV); renderGrid(); });

      document.getElementById('zin').onclick = () => { zoom = Math.min(8, +(zoom + 0.2).toFixed(2)); apply(); };
      document.getElementById('zout').onclick = () => { zoom = Math.max(0.2, +(zoom - 0.2).toFixed(2)); apply(); };
      document.getElementById('zreset').onclick = () => { zoom = 1; ox = 0; oy = 0; apply(); };
      window.addEventListener('wheel', (e) => { e.preventDefault(); const d = -Math.sign(e.deltaY)*0.12; zoom = Math.min(8, Math.max(0.2, zoom + d)); apply(); }, { passive: false });

      // Monochrome toggle
      const bwBtn = document.getElementById('bw');
      bwBtn.addEventListener('click', () => {
        monochrome = !monochrome;
        bwBtn.classList.toggle('active', monochrome);
        apply();
      });

      // Loupe toggle
      const loupeBtn = document.getElementById('loupeBtn');
      const loupe = document.getElementById('loupe');
      const magScale = 2.0;
      const radius = 120; // matches 240px diameter
      loupeBtn.addEventListener('click', () => {
        loupeOn = !loupeOn;
        loupeBtn.classList.toggle('active', loupeOn);
        if (!loupeOn) {
          loupe.style.display = 'none';
          img.style.cursor = 'grab';
        }
      });

      img.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        panning = true;
        img.setPointerCapture(e.pointerId);
        img._lastX = e.clientX;
        img._lastY = e.clientY;
        if (!(loupeOn && hovering)) img.classList.add('grabbing');
      });
      img.addEventListener('pointermove', (e) => {
        if (!panning) return;
        const dx = e.clientX - (img._lastX || e.clientX);
        const dy = e.clientY - (img._lastY || e.clientY);
        img._lastX = e.clientX;
        img._lastY = e.clientY;
        ox += dx; oy += dy; apply();
      });
      img.addEventListener('pointerup', (e) => {
        panning = false;
        try { img.releasePointerCapture(e.pointerId); } catch {}
        img.classList.remove('grabbing');
      });
      img.addEventListener('pointercancel', () => { panning = false; img.classList.remove('grabbing'); });
      img.addEventListener('dragstart', (e) => { e.preventDefault(); return false; });
      img.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      img.ondblclick = () => { zoom = 1; ox = 0; oy = 0; apply(); };
      img.addEventListener('load', () => {
        try { natW = img.naturalWidth || 0; natH = img.naturalHeight || 0; updateAspect(); } catch {}
        // Default abs values to natural size for convenience
        if (natW > 0 && natH > 0) {
          const eff = effectiveDimsPx();
          absW = String(Math.max(1, Math.round(eff.w)));
          absH = String(Math.max(1, Math.round(eff.h)));
          absWInput.value = absW;
          absHInput.value = absH;
        }
        renderMeasure();
        renderSideDistance();

        if (isPrint) {
          // Print a clean, unpanned, unzoomed view, respecting crop (stage-aligned).
          try {
            zoom = 1; ox = 0; oy = 0;
          } catch {}

          try {
            // Build a minimal print DOM so crop behaves exactly like the app's stage+clip model.
            const oldWrap = document.getElementById('wrap');
            if (oldWrap) oldWrap.style.display = 'none';

            const stage = document.createElement('div');
            stage.id = 'printStage';
            stage.style.position = 'relative';
            stage.style.overflow = 'hidden';
            stage.style.background = '#fff';
            stage.style.display = 'flex';
            stage.style.alignItems = 'center';
            stage.style.justifyContent = 'center';

            const imgBox = document.createElement('div');
            imgBox.id = 'printImgBox';
            imgBox.style.transformOrigin = 'center center';
            imgBox.style.display = 'block';

            const printImg = document.createElement('img');
            printImg.src = img.src;
            printImg.alt = '';
            printImg.style.display = 'block';
            printImg.style.width = '100%';
            printImg.style.height = '100%';

            imgBox.appendChild(printImg);
            stage.appendChild(imgBox);
            document.body.appendChild(stage);

            const clamp01 = (v) => Math.max(0, Math.min(1, v));
            const cropClip = (c) => {
              const x = clamp01(c.x);
              const y = clamp01(c.y);
              const w = Math.max(0, Math.min(1 - x, c.w));
              const h = Math.max(0, Math.min(1 - y, c.h));
              const top = y * 100;
              const left = x * 100;
              const right = (1 - x - w) * 100;
              const bottom = (1 - y - h) * 100;
              return `inset(${top}% ${right}% ${bottom}% ${left}%)`;
            };

            // Compute stage layout like the app (stage = AABB of rotated image).
            const vw = window.innerWidth || 1200;
            const vh = window.innerHeight || 800;
            const t = (rotation * Math.PI) / 180;
            const c = Math.abs(Math.cos(t));
            const s = Math.abs(Math.sin(t));

            // Fit (contain). Allow upscaling for print.
            let baseScale = Math.min(vw / natW, vh / natH);
            if (!isFinite(baseScale) || baseScale <= 0) baseScale = 1;
            let imgW = natW * baseScale;
            let imgH = natH * baseScale;
            let stageW = imgW * c + imgH * s;
            let stageH = imgW * s + imgH * c;
            const extra = Math.min(vw / stageW, vh / stageH);
            if (isFinite(extra) && extra > 0) {
              imgW *= extra; imgH *= extra; stageW *= extra; stageH *= extra;
            }

            stage.style.width = `${Math.max(1, stageW)}px`;
            stage.style.height = `${Math.max(1, stageH)}px`;
            imgBox.style.width = `${Math.max(1, imgW)}px`;
            imgBox.style.height = `${Math.max(1, imgH)}px`;
            imgBox.style.transform = `rotate(${rotation}deg)`;

            if (crop) {
              const cp = cropClip(crop);
              stage.style.clipPath = cp;
              stage.style.webkitClipPath = cp;
            }
          } catch {}

          setTimeout(() => {
            try { window.focus(); } catch {}
            try { window.print(); } catch {}
            setTimeout(() => { try { window.close(); } catch {} }, 350);
          }, 80);
        }
      });
      img.addEventListener('mouseenter', () => { hovering = true; if (loupeOn) img.style.cursor = 'none'; });
      img.addEventListener('mouseleave', () => { hovering = false; loupe.style.display = 'none'; img.style.cursor = 'grab'; });
      img.addEventListener('mousemove', (e) => {
        if (!loupeOn) return;
        const rect = img.getBoundingClientRect();
        // Cursor-relative coordinates need to be mapped into the unrotated image plane.
        // Rotation is applied on the img element, and zoom is applied on the wrap.
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = e.clientX - cx;
        const dy = e.clientY - cy;

        const theta = (-rotation * Math.PI) / 180;
        const cos = Math.cos(theta);
        const sin = Math.sin(theta);
        const ux = dx * cos - dy * sin;
        const uy = dx * sin + dy * cos;

        const w = (img.clientWidth || 0) * zoom;
        const h = (img.clientHeight || 0) * zoom;
        // Convert to "image plane" coords (top-left origin) and clamp
        const x = Math.max(0, Math.min(w, ux + w / 2));
        const y = Math.max(0, Math.min(h, uy + h / 2));
        const left = e.clientX - radius;
        const top = e.clientY - radius;
        const bgX = -(x * magScale - radius);
        const bgY = -(y * magScale - radius);
        loupe.style.display = 'block';
        loupe.style.left = left + 'px';
        loupe.style.top = top + 'px';
        loupe.style.backgroundImage = `url(${img.src})`;
        loupe.style.backgroundSize = `${w * magScale}px ${h * magScale}px`;
        loupe.style.backgroundPosition = `${bgX}px ${bgY}px`;
        loupe.style.filter = monochrome ? 'grayscale(100%)' : 'none';
        loupe.style.transform = `rotate(${rotation}deg)`;
        loupe.style.transformOrigin = 'center center';
      });

      // Measure mode toggle
      measureBtn.addEventListener('click', () => {
        measureOn = !measureOn;
        measureBtn.classList.toggle('active', measureOn);
        measurePanel.style.display = measureOn ? 'flex' : 'none';
        measureHit.style.display = measureOn ? 'block' : 'none';
        if (!measureOn) {
          draggingIdx = null;
          sideCursor = null;
          renderSideDistance();
        }
        renderMeasure();
      });

      // Measure mode selection
      document.querySelectorAll('input[name="measureMode"]').forEach(r => {
        r.addEventListener('change', (e) => {
          measureMode = e.target.value;
          absWrap.style.display = measureMode === 'absolute' ? 'block' : 'none';
          renderMeasure();
          renderSideDistance();
        });
      });

      // Absolute inputs (keep aspect sync)
      absWInput.addEventListener('input', (e) => {
        absW = e.target.value;
        if (absW !== '') {
          const wNum = parseFloat(absW);
          const aspect = effectiveAspect();
          if (isFinite(wNum) && wNum > 0 && aspect > 0) {
            absH = (wNum * aspect).toFixed(2);
            absHInput.value = absH;
          }
        }
        renderMeasure();
        renderSideDistance();
      });
      absHInput.addEventListener('input', (e) => {
        absH = e.target.value;
        if (absH !== '') {
          const hNum = parseFloat(absH);
          const aspect = effectiveAspect();
          if (isFinite(hNum) && hNum > 0 && aspect > 0) {
            absW = (hNum / aspect).toFixed(2);
            absWInput.value = absW;
          }
        }
        renderMeasure();
        renderSideDistance();
      });

      showSideInput.addEventListener('change', (e) => {
        showSide = !!e.target.checked;
        renderSideDistance();
      });

      mUndo.addEventListener('click', () => {
        if (measurePoints.length === 0) return;
        measurePoints = measurePoints.slice(0, -1);
        renderMeasure();
      });
      mReset.addEventListener('click', () => {
        measurePoints = [];
        draggingIdx = null;
        renderMeasure();
      });

      // Measurement hit area interactions (mapped through inverse rotation)
      measureHit.addEventListener('mousedown', (e) => {
        if (!measureOn) return;
        if (e.button !== 0) return;
        // If clicking near an existing point, start dragging it
        const mapped = mapClientToUnrotatedNormalized(e.clientX, e.clientY);
        const threshold = 0.015; // in normalized coords
        let found = null;
        for (let i = 0; i < measurePoints.length; i++) {
          const p = measurePoints[i];
          const d = Math.hypot(p.nx - mapped.nx, p.ny - mapped.ny);
          if (d < threshold) { found = i; break; }
        }
        if (found !== null) {
          draggingIdx = found;
        } else {
          measurePoints.push({ nx: mapped.nx, ny: mapped.ny });
          renderMeasure();
        }
      });

      window.addEventListener('mousemove', (e) => {
        if (!measureOn) return;
        if (draggingIdx !== null) {
          const mapped = mapClientToUnrotatedNormalized(e.clientX, e.clientY);
          measurePoints[draggingIdx] = { nx: mapped.nx, ny: mapped.ny };
          renderMeasure();
        }
        if (measureMode === 'absolute' && showSide) {
          const rect = wrap.getBoundingClientRect();
          const nx = clamp01((e.clientX - rect.left) / rect.width);
          const ny = clamp01((e.clientY - rect.top) / rect.height);
          sideCursor = { nx, ny };
          renderSideDistance();
        }
      });
      window.addEventListener('mouseup', () => { draggingIdx = null; });
      apply();
    </script>
  </body>
  </html>


